# Static Application Security Testing (SAST) Exercise

## üìñ Overview

Static Application Security Testing (SAST) analyses source code **without executing the programme** to identify security vulnerabilities. This exercise teaches you to **apply security features incorporated into software** by using automated tools to detect common security issues and learn remediation techniques.

**Think of it this way:** If your source code is like a written essay, SAST is like having a spell-checker and grammar checker that looks for security mistakes. It reads through all your code and flags potential problems before you hand in your work - without actually running the programme.

**This exercise aligns with these syllabus points:**
- **Static Application Security Testing (SAST)**: Source code analysis for security vulnerabilities
- **Input validation**: Data format and range verification detection
- **Defensive data input handling**: Identifying sanitization and validation gaps
- **Cryptography contribution to security by design**: Detecting weak encryption implementations
- **OWASP Top 10 vulnerabilities**: Systematic identification of common web application security risks

**Real-World Application:** Professional development teams use SAST tools in their development pipeline to catch security issues early, reducing costs and improving code quality before deployment.

## üéØ Prerequisites

### Technical Requirements
- Basic Python programming skills
- Understanding of web applications and forms
- Familiarity with command line operations
- Basic concepts of security vulnerabilities

### Environment Setup
**Navigate to main folder:**
```bash
cd /workspaces/Secure_Architecture_Sandbox_Testing_Environment
```

**Verify SAST tools are available:**
```bash
python src/analyser/analyse_cli.py --help
```

**Expected Output (first few lines):**
```
usage: analyse_cli.py [-h] [--educational] [--verbose] [--output {text,json}] file_or_directory
Static Application Security Testing (SAST) tool for educational purposes
```

**Check sample applications exist:**
```bash
ls samples/
```

**Expected Output:**
```
README.md  backdoor-apps/  network-scenarios/  resource-abuse/  suspicious-scripts/  unsecure-pwa/  vulnerable-flask-app/
```

**‚ùå If Something Goes Wrong:**
- **Can't find folders?** Run: `cd /workspaces/Secure_Architecture_Sandbox_Testing_Environment`
- **Python error?** Make sure you're in the main project folder
- **Tool not found?** Check that you're in `/workspaces/Secure_Architecture_Sandbox_Testing_Environment`

### SAST vs Other Testing Methods

| Testing Type | When | Access | Execution | Real-World Example |
|--------------|------|--------|-----------|-------------------|
| **SAST** | Development | Source Code | No | Proofreading an essay |
| **DAST** | Runtime | External Interface | Yes | Listening to a speech |
| **Manual Review** | Development | Source Code | No | Teacher reviewing work |

## üéØ Sample Applications (Your Testing Targets)

### 1. Unsecure PWA (Primary Target)
- **Location**: `samples/unsecure-pwa/`
- **Technology**: Progressive Web App with Python backend
- **Purpose**: Demonstrates modern web application security vulnerabilities
- **What you'll find**: SQL injection, XSS, weak authentication, debug mode

### 2. Vulnerable Flask Application
- **Location**: `samples/vulnerable-flask-app/`
- **Technology**: Python Flask web framework
- **Purpose**: Demonstrates additional security vulnerabilities
- **What you'll find**: Configuration issues, authentication flaws, injection vulnerabilities

## üìã Activities

### Activity 1: SAST Tool Familiarisation

**Objective:** Learn how to use the SAST analysis tools and understand their output.

**Step 1: Verify Tool Setup**
```bash
# Check you're in the correct location
cd /workspaces/Secure_Architecture_Sandbox_Testing_Environment
pwd

# Test the SAST analysis tool
python src/analyser/analyse_cli.py --help
```

**Step 2: Run Basic Security Analysis**
```bash
# Analyse the unsecure PWA (primary target) - RECOMMENDED
python src/analyser/analyse_cli.py samples/unsecure-pwa --educational --verbose
```

**Expected Output:**
```
üîç STATIC APPLICATION SECURITY TESTING (SAST) REPORT
üìÇ Target: samples/unsecure-pwa
üìÖ Scan Date: 2025-XX-XX

üîß Tools Used:
‚úÖ bandit: Python security linter
‚úÖ safety: Dependency vulnerability scanner
‚úÖ semgrep: Pattern-based security analysis

FINDINGS SUMMARY:
üö® High: 8 findings
‚ö†Ô∏è Medium: 12 findings
üîµ Low: 5 findings
Total: 25 findings
```

**What You'll See:**
- Security findings categorised by severity (High, Medium, Low)
- Educational explanations for each vulnerability type
- Specific file locations and line numbers
- Remediation suggestions

**Step 3: Understand Different Output Modes**
```bash
# Run with educational explanations
python src/analyser/analyse_cli.py samples/unsecure-pwa --educational
```

```bash
# Run verbose analysis for debugging
python src/analyser/analyse_cli.py samples/unsecure-pwa --verbose
```

```bash
# Generate JSON output for automation
python src/analyser/analyse_cli.py samples/unsecure-pwa --output pwa_report.json --format json
```

### Activity 2: Input Validation Vulnerability Detection

**Objective:** Identify and understand input validation security issues.

**Step 1: Analyse Input Validation Issues**
```bash
# Focus on the primary target - unsecure PWA
python src/analyser/analyse_cli.py samples/unsecure-pwa --educational
```

**Step 2: Find SQL Injection Vulnerabilities**
```bash
python src/analyser/analyse_cli.py samples/unsecure-pwa --educational | grep -A 5 -B 5 "SQL\|sql"
```

**Expected to see something like:**
```
üö® HIGH SEVERITY
[BANDIT] hardcoded_sql_expressions
üìÅ File: samples/unsecure-pwa/app.py
üìç Line: 89
üéì Educational Note: SQL injection vulnerability - user input is directly concatenated into SQL queries
```

**What to Look For:**
- **SQL Injection**: Direct string concatenation in database queries
- **XSS (Cross-Site Scripting)**: Unescaped user input in templates
- **Path Traversal**: Unvalidated file path inputs
- **Command Injection**: User input passed to system commands

**Step 3: Examine Actual Vulnerable Code**
```bash
# Replace LINE_NUMBER with the actual line from your findings
cat samples/unsecure-pwa/user_management.py | head -100
```

### Activity 3: Authentication and Configuration Analysis

**Objective:** Identify authentication weaknesses and insecure configurations.

**Step 1: Find Authentication Weaknesses**
```bash
python src/analyser/analyse_cli.py samples/unsecure-pwa --educational | grep -A 3 -B 3 "auth\|password\|login"
```

**Common Authentication Problems:**
- Weak password hashing (using MD5 instead of bcrypt)
- Missing rate limiting on login attempts
- Insecure session management
- Hardcoded passwords or secrets

**Step 2: Find Configuration Issues**
```bash
python src/analyser/analyse_cli.py samples/unsecure-pwa --educational | grep -A 3 -B 3 "debug\|config\|secret"
```

**Common Configuration Problems:**
- Debug mode enabled (`app.run(debug=True)`)
- Hardcoded secret keys
- Insecure cookie settings
- Missing security headers

**Step 3: Understanding a Finding**

**Sample Finding Analysis:**
```
üö® HIGH SEVERITY
[BANDIT] flask_debug_true
üìÅ File: samples/unsecure-pwa/app.py
üìç Line: 522
üéì Educational Note: Flask debug mode should not be enabled in production as it can expose sensitive information and allow code execution.
üîß Remediation: Set debug=False in production. Use environment variables to control debug mode.
```

**What this means:**
- **üö® HIGH SEVERITY**: This is a serious security problem
- **[BANDIT]**: The tool that found this issue
- **flask_debug_true**: The type of vulnerability
- **üìÅ File & üìç Line**: Exactly where the problem is
- **üéì Educational Note**: Why this is dangerous
- **üîß Remediation**: How to fix it

### Activity 4: Comparative Analysis

**Objective:** Compare security findings across different applications.

**Step 1: Analyse the Flask Application**
```bash
python src/analyser/analyse_cli.py samples/vulnerable-flask-app --educational --verbose
```

**Step 2: Create Comparison Report**
```bash
# Run analysis on both applications and compare
echo '=== UNSECURE PWA ===' > security_comparison.txt
python src/analyser/analyse_cli.py samples/unsecure-pwa --educational | grep "FINDINGS SUMMARY" -A 10 >> security_comparison.txt

echo '=== FLASK APP ===' >> security_comparison.txt
python src/analyser/analyse_cli.py samples/vulnerable-flask-app --educational | grep "FINDINGS SUMMARY" -A 10 >> security_comparison.txt

cat security_comparison.txt
```

**Step 3: Generate JSON Reports for Automation**
```bash
# Generate JSON reports
python src/analyser/analyse_cli.py samples/unsecure-pwa --output pwa_report.json --format json
python src/analyser/analyse_cli.py samples/vulnerable-flask-app --output flask_report.json --format json

# Count findings
echo "PWA findings count:" && cat pwa_report.json | grep -o '"severity"' | wc -l
echo "Flask findings count:" && cat flask_report.json | grep -o '"severity"' | wc -l
```

### Activity 5: Remediation Planning

**Objective:** Learn to prioritise and document security findings for remediation.

**Step 1: Generate Summary Report**
```bash
# Generate summary report
python src/analyser/analyse_cli.py samples/unsecure-pwa --educational > vulnerability_report.txt

# Review high-priority issues first
grep -A 5 "üö® High:" vulnerability_report.txt
```

**Step 2: Create Priority Matrix**

Create a remediation priority matrix based on your findings:

| Vulnerability | Severity | Exploitability | Impact | Priority |
|--------------|----------|----------------|--------|----------|
| SQL Injection | High | Easy | High | 1 |
| Debug Mode | Medium | Medium | Medium | 2 |
| Weak Authentication | High | Medium | High | 3 |

**Step 3: Map to OWASP Top 10**

Which OWASP categories did you find?
- [ ] A01: Broken Access Control
- [ ] A02: Cryptographic Failures
- [ ] A03: Injection
- [ ] A04: Insecure Design
- [ ] A05: Security Misconfiguration
- [ ] A06: Vulnerable Components
- [ ] A07: Identification/Authentication Failures
- [ ] A08: Software/Data Integrity Failures
- [ ] A09: Security Logging/Monitoring Failures
- [ ] A10: Server-Side Request Forgery

## üìù Summary

### Key Vulnerability Types to Identify

Through SAST analysis, you should discover these critical security issues:

**1. SQL Injection (A03 - Injection)**
- **Detection**: String concatenation in SQL queries, missing parameterization
- **Impact**: Database compromise, data theft, unauthorized access
- **Syllabus Connection**: Input validation and sanitization failures

**2. Cross-Site Scripting - XSS (A03 - Injection)**
- **Detection**: Unescaped user input in HTML templates, unsafe output encoding
- **Impact**: Session hijacking, malicious script execution, data theft
- **Syllabus Connection**: Output encoding and defensive programming

**3. Hard-coded Secrets (A02 - Cryptographic Failures)**
- **Detection**: API keys, passwords, tokens embedded in source code
- **Impact**: Unauthorized system access, credential compromise
- **Syllabus Connection**: Cryptographic security and secure key management

**4. Vulnerable Dependencies (A06 - Vulnerable Components)**
- **Detection**: Outdated libraries with known CVEs, insecure packages
- **Impact**: Remote code execution, system compromise via third-party code
- **Syllabus Connection**: Security testing and evaluation of components

**5. Security Misconfiguration (A05 - Security Misconfiguration)**
- **Detection**: Debug mode enabled, default credentials, verbose error messages
- **Impact**: Information disclosure, unauthorized access, system exposure
- **Syllabus Connection**: Secure application configuration and deployment

### Skills Developed

By completing this exercise, you have practiced:
- **Automated security testing**: Using SAST tools for vulnerability detection
- **Vulnerability interpretation**: Understanding and prioritising security findings
- **OWASP Top 10 mapping**: Connecting findings to industry-standard vulnerability categories
- **Remediation planning**: Understanding how to fix common security issues

### Real-World Applications

SAST is essential in professional software development because:
- Catches security issues early in the development lifecycle (shift-left security)
- Reduces costs by finding vulnerabilities before deployment
- Provides comprehensive code coverage without execution requirements
- Educates developers about secure coding practices through automated feedback

SAST tools integrate with development workflows and complement **Dynamic Application Security Testing (DAST)** and **manual code review** for comprehensive security coverage.

## üéØ Real-World Applications

### Industry Use Cases
- **DevSecOps Pipelines**: Automated security scanning in CI/CD
- **Code Review Enhancement**: Supporting manual review with automated detection
- **Compliance Validation**: Meeting security standards (ISM, ISO27001)
- **Developer Training**: Learning secure coding through immediate feedback

### Career Connections
- **Application Security Engineer**: Implements and manages SAST tools
- **Security Consultant**: Performs security assessments using SAST
- **DevSecOps Engineer**: Integrates security testing into development pipelines
- **Software Developer**: Uses SAST to write more secure code

## üìö Additional Resources

### Industry Standards
- OWASP Application Security Verification Standard (ASVS)
- NIST Cybersecurity Framework
- Common Weakness Enumeration (CWE)

### Tools for Further Learning
- **Bandit**: Python-specific security linter
- **Semgrep**: Pattern-based code analysis
- **SonarQube**: Comprehensive code quality and security platform
- **Snyk**: Dependency vulnerability scanning

---

**Next Steps:** Apply SAST findings alongside manual code review and DAST testing to build a complete security testing methodology. Progress to the Dynamic Application Security Testing (DAST) exercise to learn runtime vulnerability detection.
