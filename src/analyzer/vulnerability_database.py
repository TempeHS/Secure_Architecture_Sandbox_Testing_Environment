"""
Educational Vulnerability Database for Cybersecurity Learning

This module provides comprehensive educational content about common web application
vulnerabilities, specifically focusing on the OWASP Top 10 and educational explanations
for high school students learning cybersecurity concepts.

Focus Areas:
1. Cross-Site Scripting (XSS)
2. Cross-Site Request Forgery (CSRF)
3. SQL Injection
4. Unvalidated Redirects and Forwards
"""

from dataclasses import dataclass
from typing import Dict, List, Optional
import re


@dataclass
class VulnerabilityInfo:
    """Educational information about a specific vulnerability type."""
    name: str
    severity: str
    owasp_category: str
    description: str
    educational_explanation: str
    student_friendly_description: str
    how_it_works: str
    real_world_examples: List[str]
    prevention_techniques: List[str]
    code_examples: Dict[str, str]
    remediation_steps: List[str]
    learning_resources: List[str]


class VulnerabilityDatabase:
    """
    Comprehensive database of vulnerability information for educational purposes.

    This class provides detailed, student-friendly explanations of common web
    application vulnerabilities with practical examples and remediation guidance.
    """

    def __init__(self):
        self.vulnerabilities = self._initialize_vulnerability_database()
        self.pattern_mappings = self._initialize_pattern_mappings()

    def _initialize_vulnerability_database(self) -> Dict[str, VulnerabilityInfo]:
        """Initialize the vulnerability database with educational content."""

        return {
            "xss": VulnerabilityInfo(
                name="Cross-Site Scripting (XSS)",
                severity="High",
                owasp_category="A03:2021 â€“ Injection",
                description="XSS vulnerabilities allow attackers to inject malicious scripts into web pages viewed by other users.",
                educational_explanation=(
                    "Imagine a website that displays user comments without checking them first. "
                    "An attacker could write a 'comment' that's actually JavaScript code. When other "
                    "users view the page, this malicious code runs in their browser, potentially "
                    "stealing their login cookies or redirecting them to fake websites."
                ),
                student_friendly_description=(
                    "XSS is like someone writing graffiti that becomes 'magical' and affects everyone "
                    "who looks at it. Instead of harmless text, attackers inject code that runs when "
                    "others visit the page."
                ),
                how_it_works=(
                    "1. Attacker finds input field that displays user data\n"
                    "2. Attacker enters malicious JavaScript code instead of normal text\n"
                    "3. Website stores and displays this code without sanitizing it\n"
                    "4. When other users view the page, the malicious code executes\n"
                    "5. Attacker can steal cookies, redirect users, or modify page content"
                ),
                real_world_examples=[
                    "MySpace worm (2005) - Spread to over 1 million users in 20 hours",
                    "TweetDeck XSS (2014) - Caused tweets to retweet themselves automatically",
                    "eBay XSS (2014) - Allowed attackers to steal user credentials"
                ],
                prevention_techniques=[
                    "Input validation - Check all user input before processing",
                    "Output encoding - Convert special characters to safe equivalents",
                    "Content Security Policy (CSP) - Restrict which scripts can run",
                    "Use template engines with automatic escaping",
                    "Validate input on both client and server side"
                ],
                code_examples={
                    "vulnerable": '''
# Vulnerable Flask code - DON'T DO THIS
@app.route('/comment')
def show_comment():
    user_comment = request.args.get('comment')
    return f"<p>User said: {user_comment}</p>"  # DANGEROUS!

# Attacker could use: ?comment=<script>alert('XSS')</script>
''',
                    "secure": '''
# Secure Flask code - DO THIS
from markupsafe import escape

@app.route('/comment')
def show_comment():
    user_comment = request.args.get('comment')
    safe_comment = escape(user_comment)  # Escapes HTML/JS
    return f"<p>User said: {safe_comment}</p>"

# Or use template with auto-escaping:
return render_template('comment.html', comment=user_comment)
'''
                },
                remediation_steps=[
                    "Identify all user input points in your application",
                    "Implement input validation for expected data types",
                    "Use output encoding/escaping for all dynamic content",
                    "Implement Content Security Policy headers",
                    "Use security-focused template engines",
                    "Regularly test with XSS detection tools"
                ],
                learning_resources=[
                    "OWASP XSS Prevention Cheat Sheet",
                    "Mozilla Developer Network - XSS Guide",
                    "PortSwigger Web Security Academy - XSS Labs"
                ]
            ),

            "csrf": VulnerabilityInfo(
                name="Cross-Site Request Forgery (CSRF)",
                severity="Medium",
                owasp_category="A01:2021 â€“ Broken Access Control",
                description="CSRF tricks users into performing unintended actions on websites where they're authenticated.",
                educational_explanation=(
                    "Imagine you're logged into your bank's website in one browser tab. In another tab, "
                    "you visit a malicious website that secretly contains a hidden form. This form "
                    "automatically submits a money transfer request to your bank using your existing "
                    "login session. The bank thinks YOU made the request because you're logged in!"
                ),
                student_friendly_description=(
                    "CSRF is like someone forging your signature on a document while you're not looking, "
                    "but using your own pen (your login session). The bank thinks it's really you "
                    "because they recognize your pen."
                ),
                how_it_works=(
                    "1. User logs into a legitimate website (bank, email, social media)\n"
                    "2. User visits a malicious website while still logged in\n"
                    "3. Malicious site contains hidden forms or JavaScript\n"
                    "4. These forms automatically submit requests to the legitimate site\n"
                    "5. Legitimate site accepts the request because user is authenticated\n"
                    "6. Unwanted action is performed (money transfer, password change, etc.)"
                ),
                real_world_examples=[
                    "Netflix CSRF (2008) - Allowed changing account passwords",
                    "YouTube CSRF (2008) - Could add users to friends lists",
                    "Gmail CSRF (2007) - Allowed reading private emails"
                ],
                prevention_techniques=[
                    "CSRF tokens - Unique tokens for each form submission",
                    "SameSite cookie attribute - Prevents cross-site cookie usage",
                    "Double submit cookies - Verify cookies match form data",
                    "Origin/Referer header validation",
                    "Require re-authentication for sensitive actions"
                ],
                code_examples={
                    "vulnerable": '''
# Vulnerable Flask code - DON'T DO THIS
@app.route('/transfer', methods=['POST'])
def transfer_money():
    if 'user_id' in session:  # User is logged in
        amount = request.form['amount']
        to_account = request.form['to_account']
        # Process transfer - NO CSRF PROTECTION!
        return "Transfer completed"
    return "Not logged in"

# Attacker's malicious site could include:
# <form action="http://yourbank.com/transfer" method="POST">
#   <input type="hidden" name="amount" value="1000">
#   <input type="hidden" name="to_account" value="attacker_account">
# </form>
# <script>document.forms[0].submit();</script>
''',
                    "secure": '''
# Secure Flask code - DO THIS
from flask_wtf.csrf import CSRFProtect

csrf = CSRFProtect(app)

@app.route('/transfer', methods=['POST'])
def transfer_money():
    if 'user_id' in session:
        # CSRF token automatically validated by flask_wtf
        amount = request.form['amount']
        to_account = request.form['to_account']
        
        # Additional validation
        if not validate_account(to_account):
            return "Invalid account"
            
        # Process transfer with CSRF protection
        return "Transfer completed"
    return "Not logged in"

# In template:
# {{ csrf_token() }}  # Includes CSRF token in form
'''
                },
                remediation_steps=[
                    "Implement CSRF tokens for all state-changing operations",
                    "Use SameSite=Strict or SameSite=Lax for cookies",
                    "Validate Origin and Referer headers",
                    "Require re-authentication for sensitive actions",
                    "Use POST requests for state changes, not GET",
                    "Consider implementing time-limited tokens"
                ],
                learning_resources=[
                    "OWASP CSRF Prevention Cheat Sheet",
                    "Flask-WTF CSRF Protection Documentation",
                    "Django CSRF Protection Guide"
                ]
            ),

            "sql_injection": VulnerabilityInfo(
                name="SQL Injection",
                severity="Critical",
                owasp_category="A03:2021 â€“ Injection",
                description="SQL injection allows attackers to interfere with database queries by injecting malicious SQL code.",
                educational_explanation=(
                    "Imagine a library where you can request books by filling out a form. Normally, "
                    "you'd write 'Harry Potter' and the librarian would find that book. But what if "
                    "you wrote 'Harry Potter; also give me all books and customer information'? "
                    "If the librarian blindly follows your request without questioning the extra "
                    "commands, you'd get access to everything in the library!"
                ),
                student_friendly_description=(
                    "SQL injection is like tricking a database into running extra commands by "
                    "disguising them as normal search requests. It's like asking for a book but "
                    "secretly also asking for the keys to the entire library."
                ),
                how_it_works=(
                    "1. Application takes user input for database queries\n"
                    "2. Input is directly inserted into SQL query without validation\n"
                    "3. Attacker crafts input containing SQL commands\n"
                    "4. Database executes both intended query and malicious commands\n"
                    "5. Attacker can read, modify, or delete database information\n"
                    "6. In worst cases, attacker gains complete database control"
                ),
                real_world_examples=[
                    "TalkTalk hack (2015) - 4 million customer records stolen",
                    "Heartland Payment Systems (2008) - 134 million credit cards compromised",
                    "Sony Pictures (2011) - 1 million accounts compromised"
                ],
                prevention_techniques=[
                    "Parameterized queries - Separate SQL code from data",
                    "Stored procedures with proper input validation",
                    "Input validation and sanitization",
                    "Least privilege database access",
                    "Web Application Firewalls (WAF)",
                    "Regular security testing and code reviews"
                ],
                code_examples={
                    "vulnerable": '''
# Vulnerable Python code - DON'T DO THIS
def get_user(username):
    query = f"SELECT * FROM users WHERE username = '{username}'"
    cursor.execute(query)  # DANGEROUS!
    return cursor.fetchone()

# Attacker input: "admin'; DROP TABLE users; --"
# Resulting query: SELECT * FROM users WHERE username = 'admin'; DROP TABLE users; --'
# This would DELETE the entire users table!
''',
                    "secure": '''
# Secure Python code - DO THIS
def get_user(username):
    # Parameterized query - data separated from SQL code
    query = "SELECT * FROM users WHERE username = ?"
    cursor.execute(query, (username,))  # Safe!
    return cursor.fetchone()

# Or with SQLAlchemy ORM:
def get_user(username):
    return db.session.query(User).filter(User.username == username).first()
'''
                },
                remediation_steps=[
                    "Replace all dynamic SQL with parameterized queries",
                    "Implement input validation for all user inputs",
                    "Use ORM frameworks when possible",
                    "Apply principle of least privilege to database accounts",
                    "Enable SQL query logging and monitoring",
                    "Regular penetration testing for SQL injection"
                ],
                learning_resources=[
                    "OWASP SQL Injection Prevention Cheat Sheet",
                    "SQLMap Tool for Testing SQL Injection",
                    "PortSwigger SQL Injection Labs"
                ]
            ),

            "unvalidated_redirects": VulnerabilityInfo(
                name="Unvalidated Redirects and Forwards",
                severity="Medium",
                owasp_category="A01:2021 â€“ Broken Access Control",
                description="Applications that redirect users to untrusted URLs can be abused for phishing attacks.",
                educational_explanation=(
                    "Imagine a trusted website (like your bank) has a feature that redirects you to "
                    "other pages. An attacker could create a link that looks like it goes to your bank, "
                    "but actually redirects you to a fake bank website that steals your login credentials. "
                    "Since the link starts with your real bank's URL, it looks trustworthy!"
                ),
                student_friendly_description=(
                    "Unvalidated redirects are like a trusted tour guide who doesn't check where "
                    "they're taking you. You trust the guide, but they might accidentally lead you "
                    "into danger because they didn't verify the destination was safe."
                ),
                how_it_works=(
                    "1. Legitimate website has redirect functionality\n"
                    "2. URL parameter controls where user gets redirected\n"
                    "3. Attacker crafts malicious URL with evil redirect destination\n"
                    "4. Attacker sends link to victims (email, social media, etc.)\n"
                    "5. Victims click link thinking it's safe (trusted domain)\n"
                    "6. Legitimate site redirects to attacker's malicious site\n"
                    "7. Victims enter credentials on fake site"
                ),
                real_world_examples=[
                    "PayPal redirect vulnerability - Used for phishing attacks",
                    "Government websites - Redirected users to malicious sites",
                    "Social media platforms - Bypassed URL filters"
                ],
                prevention_techniques=[
                    "Whitelist allowed redirect destinations",
                    "Validate all redirect URLs against approved list",
                    "Use relative URLs instead of absolute URLs",
                    "Implement redirect confirmation pages",
                    "Avoid using user input directly in redirects"
                ],
                code_examples={
                    "vulnerable": '''
# Vulnerable Flask code - DON'T DO THIS
@app.route('/redirect')
def redirect_user():
    url = request.args.get('url')
    return redirect(url)  # DANGEROUS!

# Attacker could use:
# http://yoursite.com/redirect?url=http://evil-site.com/fake-login
# Users trust yoursite.com domain but get redirected to attacker's site
''',
                    "secure": '''
# Secure Flask code - DO THIS
@app.route('/redirect')
def redirect_user():
    url = request.args.get('url')
    
    # Whitelist of allowed redirect domains
    allowed_domains = ['yoursite.com', 'partner-site.com']
    
    if url:
        parsed_url = urlparse(url)
        if parsed_url.netloc in allowed_domains:
            return redirect(url)
        else:
            # Log suspicious redirect attempt
            app.logger.warning(f"Blocked redirect to: {url}")
            return "Invalid redirect destination", 400
    
    return redirect(url_for('home'))  # Safe default

# Alternative: Use relative URLs only
@app.route('/redirect')
def redirect_user():
    page = request.args.get('page')
    # Only allow redirects to internal pages
    if page in ['dashboard', 'profile', 'settings']:
        return redirect(url_for(page))
    return redirect(url_for('home'))
'''
                },
                remediation_steps=[
                    "Audit all redirect functionality in your application",
                    "Implement whitelist of allowed redirect destinations",
                    "Use relative URLs for internal redirects",
                    "Add confirmation pages for external redirects",
                    "Log and monitor redirect attempts",
                    "Educate users about phishing through redirects"
                ],
                learning_resources=[
                    "OWASP Unvalidated Redirects Prevention",
                    "Open Redirect Vulnerability Guide",
                    "Phishing Attack Prevention Techniques"
                ]
            ),

            "broken_authentication": VulnerabilityInfo(
                name="Broken Authentication",
                severity="Critical",
                owasp_category="A07:2021 â€“ Identification and Authentication Failures",
                description="Authentication mechanisms are incorrectly implemented, allowing attackers to compromise passwords, keys, or session tokens.",
                educational_explanation=(
                    "Think of authentication like checking IDs at a concert. Broken authentication "
                    "is like having security guards who don't properly check IDs, accept fake IDs, "
                    "or let people share tickets. Attackers can exploit these weaknesses to pretend "
                    "to be other users, access accounts without passwords, or bypass security entirely."
                ),
                student_friendly_description=(
                    "Broken authentication is like having a broken lock on your front door. "
                    "Even if you have a key, the lock might be so broken that anyone can open it, "
                    "or someone might be able to pick it easily because it's poorly made."
                ),
                how_it_works=(
                    "1. Attacker identifies weak authentication mechanisms\n"
                    "2. Exploits flaws like weak passwords, missing rate limiting, or poor session handling\n"
                    "3. Gains unauthorized access to user accounts\n"
                    "4. Can impersonate legitimate users\n"
                    "5. Access sensitive data or perform actions as the compromised user\n"
                    "6. May escalate privileges to gain admin access"
                ),
                real_world_examples=[
                    "Adobe breach (2013) - 38 million accounts with weak password hashing",
                    "Twitter hack (2020) - Social engineering bypassed authentication",
                    "Equifax breach (2017) - Weak authentication on admin panels"
                ],
                prevention_techniques=[
                    "Implement multi-factor authentication (MFA)",
                    "Use strong password policies and validation",
                    "Implement account lockout after failed attempts",
                    "Use secure session management",
                    "Implement proper password hashing (bcrypt, scrypt, Argon2)",
                    "Regular security audits of authentication flows"
                ],
                code_examples={
                    "vulnerable": '''
# Vulnerable authentication - DON'T DO THIS
@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form['password']
    
    # Weak: Plain text password comparison
    user = db.query(f"SELECT * FROM users WHERE username='{username}' AND password='{password}'")
    
    if user:
        session['user'] = username  # Weak session management
        return "Login successful"
    return "Login failed"

# Problems:
# 1. SQL injection vulnerability
# 2. Plain text password storage
# 3. No rate limiting
# 4. Weak session management
''',
                    "secure": '''
# Secure authentication - DO THIS
from werkzeug.security import check_password_hash
from flask_limiter import Limiter
import secrets

limiter = Limiter(app)

@app.route('/login', methods=['POST'])
@limiter.limit("5 per minute")  # Rate limiting
def login():
    username = request.form['username']
    password = request.form['password']
    
    # Secure: Parameterized query and hashed passwords
    user = db.session.query(User).filter(User.username == username).first()
    
    if user and check_password_hash(user.password_hash, password):
        # Secure session management
        session['user_id'] = user.id
        session['csrf_token'] = secrets.token_hex(16)
        session.permanent = True
        app.permanent_session_lifetime = timedelta(hours=1)
        
        # Log successful login
        app.logger.info(f"Successful login for user: {username}")
        return redirect(url_for('dashboard'))
    else:
        # Log failed attempt
        app.logger.warning(f"Failed login attempt for user: {username}")
        return "Invalid credentials", 401
'''
                },
                remediation_steps=[
                    "Implement strong password policies (length, complexity)",
                    "Use secure password hashing algorithms (bcrypt, Argon2)",
                    "Add multi-factor authentication where possible",
                    "Implement rate limiting on login attempts",
                    "Use secure session management practices",
                    "Regular security testing of authentication flows"
                ],
                learning_resources=[
                    "OWASP Authentication Cheat Sheet",
                    "NIST Digital Identity Guidelines",
                    "Flask-Login Documentation for Secure Sessions"
                ]
            ),

            "broken_session_management": VulnerabilityInfo(
                name="Broken Session Management",
                severity="High",
                owasp_category="A07:2021 â€“ Identification and Authentication Failures",
                description="Session tokens are not properly protected, leading to session hijacking or fixation attacks.",
                educational_explanation=(
                    "Imagine sessions like wristbands at an amusement park that prove you paid for admission. "
                    "Broken session management is like using wristbands that are easy to copy, never expire, "
                    "or can be stolen and reused by others. An attacker could copy your wristband and get "
                    "free access to everything you paid for, or even worse, access areas you're not supposed to see."
                ),
                student_friendly_description=(
                    "Session management is like keeping track of who's logged in using a special ticket. "
                    "When it's broken, it's like the tickets are made of paper that anyone can copy, "
                    "or they never expire so old tickets still work forever."
                ),
                how_it_works=(
                    "1. User logs in and receives a session token\n"
                    "2. Weak session management allows token to be stolen or predicted\n"
                    "3. Attacker obtains valid session token through various methods\n"
                    "4. Attacker uses stolen token to impersonate legitimate user\n"
                    "5. Can access all resources available to the original user\n"
                    "6. May persist access even after user logs out"
                ),
                real_world_examples=[
                    "Firesheep (2010) - Demonstrated session hijacking on public WiFi",
                    "Various banking trojans that steal session cookies",
                    "Social media session fixation attacks"
                ],
                prevention_techniques=[
                    "Use secure, random session tokens",
                    "Implement proper session expiration",
                    "Use secure cookie flags (HttpOnly, Secure, SameSite)",
                    "Regenerate session IDs after login",
                    "Implement proper session invalidation on logout",
                    "Monitor for suspicious session activity"
                ],
                code_examples={
                    "vulnerable": '''
# Vulnerable session management - DON'T DO THIS
@app.route('/login', methods=['POST'])
def login():
    if authenticate_user(username, password):
        # Weak: Predictable session ID
        session_id = f"user_{username}_{int(time.time())}"
        session['id'] = session_id
        
        # Weak: Session never expires
        response = make_response("Login successful")
        response.set_cookie('session_id', session_id)  # No security flags
        return response

# Problems:
# 1. Predictable session IDs
# 2. No session expiration
# 3. Missing security cookie flags
# 4. No session regeneration
''',
                    "secure": '''
# Secure session management - DO THIS
import secrets
from datetime import datetime, timedelta

@app.route('/login', methods=['POST'])
def login():
    if authenticate_user(username, password):
        # Secure: Cryptographically random session ID
        session_id = secrets.token_urlsafe(32)
        
        # Secure session storage with expiration
        session_data = {
            'user_id': user.id,
            'username': username,
            'created_at': datetime.utcnow(),
            'expires_at': datetime.utcnow() + timedelta(hours=2)
        }
        
        # Store in secure session store
        session_store[session_id] = session_data
        
        response = make_response("Login successful")
        # Secure cookie flags
        response.set_cookie(
            'session_id', 
            session_id,
            secure=True,      # Only sent over HTTPS
            httponly=True,    # Not accessible via JavaScript
            samesite='Lax',   # CSRF protection
            max_age=7200      # 2 hours expiration
        )
        
        return response

@app.route('/logout', methods=['POST'])
def logout():
    session_id = request.cookies.get('session_id')
    if session_id in session_store:
        del session_store[session_id]  # Proper cleanup
    
    response = make_response("Logged out")
    response.set_cookie('session_id', '', expires=0)  # Clear cookie
    return response
'''
                },
                remediation_steps=[
                    "Use cryptographically secure random session tokens",
                    "Implement appropriate session timeouts",
                    "Set secure cookie flags (Secure, HttpOnly, SameSite)",
                    "Regenerate session IDs after privilege changes",
                    "Implement proper session cleanup on logout",
                    "Monitor and log session-related security events"
                ],
                learning_resources=[
                    "OWASP Session Management Cheat Sheet",
                    "Flask Session Security Best Practices",
                    "Web Security Session Hijacking Prevention"
                ]
            )
        }

    def _initialize_pattern_mappings(self) -> Dict[str, str]:
        """Map common vulnerability patterns to vulnerability types."""
        return {
            # XSS patterns
            "template.*format.*string": "xss",
            "server.*side.*template.*injection": "xss",
            "cross.*site.*scripting": "xss",
            "script.*injection": "xss",

            # CSRF patterns
            "csrf": "csrf",
            "cross.*site.*request.*forgery": "csrf",
            "state.*changing.*without.*token": "csrf",

            # SQL Injection patterns
            "sql.*injection": "sql_injection",
            "hardcoded.*sql.*expressions": "sql_injection",
            "user.*input.*sql": "sql_injection",
            "string.*concatenation.*sql": "sql_injection",
            "formatted.*sql.*query": "sql_injection",

            # Redirect patterns
            "open.*redirect": "unvalidated_redirects",
            "unvalidated.*redirect": "unvalidated_redirects",
            "redirect.*user.*input": "unvalidated_redirects",
            "untrusted.*redirect": "unvalidated_redirects",

            # Authentication patterns
            "weak.*password": "broken_authentication",
            "hardcoded.*password": "broken_authentication",
            "authentication.*bypass": "broken_authentication",
            "login.*brute.*force": "broken_authentication",
            "password.*policy": "broken_authentication",
            "authentication.*failure": "broken_authentication",
            "weak.*authentication": "broken_authentication",

            # Session management patterns
            "session.*hijack": "broken_session_management",
            "session.*fixation": "broken_session_management",
            "insecure.*cookie": "broken_session_management",
            "session.*timeout": "broken_session_management",
            "session.*management": "broken_session_management",
            "cookie.*security": "broken_session_management",
            "session.*token": "broken_session_management"
        }

    def get_vulnerability_info(self, vuln_type: str) -> Optional[VulnerabilityInfo]:
        """Get detailed information about a vulnerability type."""
        return self.vulnerabilities.get(vuln_type.lower())

    def identify_vulnerability_type(self, finding_description: str) -> Optional[str]:
        """
        Identify vulnerability type from finding description.

        Args:
            finding_description: Description from security tool output

        Returns:
            Vulnerability type key or None if not found
        """
        description_lower = finding_description.lower()

        for pattern, vuln_type in self.pattern_mappings.items():
            if re.search(pattern, description_lower):
                return vuln_type

        return None

    def get_educational_explanation(self, finding_description: str) -> str:
        """
        Get educational explanation for a finding.

        Args:
            finding_description: Description from security tool

        Returns:
            Educational explanation or generic message
        """
        vuln_type = self.identify_vulnerability_type(finding_description)

        if vuln_type and vuln_type in self.vulnerabilities:
            info = self.vulnerabilities[vuln_type]
            return f"{info.educational_explanation}\n\nðŸŽ¯ Focus: {info.student_friendly_description}"

        return "Security pattern detected - review for potential vulnerabilities."

    def get_remediation_advice(self, finding_description: str) -> str:
        """
        Get specific remediation advice for a finding.

        Args:
            finding_description: Description from security tool

        Returns:
            Remediation advice or generic guidance
        """
        vuln_type = self.identify_vulnerability_type(finding_description)

        if vuln_type and vuln_type in self.vulnerabilities:
            info = self.vulnerabilities[vuln_type]
            primary_steps = info.remediation_steps[:3]  # Top 3 steps
            return " â€¢ ".join(primary_steps)

        return "Review the code and implement appropriate security controls."

    def get_learning_summary(self, vulnerability_types: List[str]) -> Dict[str, any]:
        """
        Generate learning summary for found vulnerability types.

        Args:
            vulnerability_types: List of detected vulnerability types

        Returns:
            Dictionary with learning recommendations and insights
        """
        found_vulns = []
        all_resources = []
        prevention_focus = []

        for vuln_type in set(vulnerability_types):  # Remove duplicates
            if vuln_type in self.vulnerabilities:
                info = self.vulnerabilities[vuln_type]
                found_vulns.append({
                    "name": info.name,
                    "severity": info.severity,
                    "owasp": info.owasp_category
                })
                all_resources.extend(info.learning_resources)
                prevention_focus.extend(
                    info.prevention_techniques[:2])  # Top 2

        return {
            "vulnerabilities_found": found_vulns,
            # Remove duplicates
            "learning_resources": list(set(all_resources)),
            "prevention_focus": list(set(prevention_focus)),
            "next_steps": [
                "Practice secure coding with the vulnerable demo applications",
                "Study the OWASP Top 10 security risks",
                "Learn about security testing tools and techniques",
                "Understand the impact of security vulnerabilities"
            ]
        }


# Global instance for easy access
vulnerability_db = VulnerabilityDatabase()
